\section{Digital Signatures and Message Authentication Codes}
\\Goal: Send a message with an authentication code to prevent tampering
\begin{itemize}
\item Signature Function
    \begin{itemize}
    \item $\sigma = s =$ sign(m)
    \item Public Key Encryption
    \\ Private key: signing key, Public key: verification key
        \begin{itemize}
        \item $\sigma = \text{sign}_{priv}(m)$
        \item $\text{bool verify}_{pub}(m, \sigma)$
        \end{itemize}
    \item Breaking a signature scheme; adversarial model
        \begin{itemize}
        \item Key-only attack: access to public key
        \item Known message attack: access to messages and their signatures (no choice)
        \item Chosen message attack: Choose specific message signature pairs. Strictly more powerful than those above. Oracle. All requests in one shot.
        \item Adaptive chosen message attack: Change messages to sign after each response from the oracle.
        \end{itemize}
    \item Attack models
        \begin{itemize}
        \item Total Break: found private key
        \item Universal Forgery: Algorithm is efficient, equivalent to private key
        \item Selective Forgery: Alice chooses messages that can be forged
        \item Existential Forgery: Able to forge a signature for some message
        \end{itemize}
    \item Existential Forgery Example with RSA
        \begin{itemize}
        \item Signer: (Private) $p, q, d = e^-1 \text{mod} \phi$
        \item Verifier: $e,n$
        \end{itemize}
    \end{itemize}
\end{itemize}